Микропроцессор 6502

 Версия 1.02. Автор: _Bnu.
 Перевод: Macmep.

 Большая часть следующей информации взята из "Руководства программиста
Commodore 64" просто потому что оно было доступно в электронном виде, и,
кажется, нет разницы между этой документацией и документацией 6502, они оба из
семейства 6500. Я сделал изменения и дополнения, где необходимо.

 Теоретически вам можно будет использовать любой код, который вы можете найти
для эмуляции 6510 (процессор C64).



  Регистры внутри микропроцессора 6502

    Почти все вычисления выполняются в микропроцессоре. Регистрами являются
  специальные участки памяти в процессоре, которые используются для
  выполнения, а также хранения информации о вычислениях. Процессор 6502 имеет
  следующие регистры:


  АККУМУЛЯТОР

    Это САМЫЙ важный регистр в микропроцессоре. Различные инструкции
  машинного языка позволяют вам копировать содержимое ячеек памяти в
  аккумулятор, содержимое аккумулятора в ячейки памяти, изменять содержимое
  аккумулятора или другого регистра напрямую, без обращения к памяти. Также
  аккумулятор - единственный регистр, который имеет инструкции для 
  математических вычислений.


  ИНДЕКСНЫЙ РЕГИСТР X

    Это очень важный регистр. Здесь есть иструкции для приблизительно всех
  преобразований, которые вы можете сделать с аккумулятором. Но существуют
  другие инструкции для вещей, которые может делать только регистр X.
  Различные инструкции машинного языка позволяют вам копировать содержимое
  ячейки памяти в регистр X и изменять содержимое регистра X или некоторых
  других регистров напрямую.


  ИНДЕКСНЫЙ РЕГИСТР Y

    Это очень важный регистр. Здесь есть иструкции для приблизительно всех
  преобразований, которые вы можете сделать с аккумулятором и регистром X.
  Но существуют другие инструкции для вещей, которые может делать только
  регистр Y. Различные инструкции машинного языка позволяют вам копировать
  содержимое ячейки памяти в регистр Y и изменять содержимое регистра Y или
  некоторых других регистров напрямую.


  РЕГИСТР СОСТОЯНИЯ

    Этот регистр состоит из 8 "флагов" (флаг - это нечто, что показывает, что
  либо что-то произошло, либо не произошло). Биты этого регистра изменяются в
  зависимости от результата арифметических или логических операций. Эти биты
  описаны ниже:

     Номер бита:   7   6   5   4   3   2   1   0
                   S   V       B   D   I   Z   C

   Бит 0 - C - флаг переноса (Carry): содержит перенос самого значащего бита
   в любой арифметической операции. В операциях вычитания, однако, этот флаг
   очищен - установлен в 0 - если необходимо занять единицу, установлен в 1 -
   если занимать единицу не нужно. Флаг переноса также используется в
   логических операциях сдвига и циклического сдвига.

   Бит 1 - Z - флаг нуля: устанавливается в 1, когда любая арифметическая
   операция возвращает нулевой результат, и устанавливается в 0, когда
   результат ненулевой.

   Бит 2 - I: флаг прерывания. Если он установлен, прерывания запрещены. Если
   он очищен, прерывания разрешены.

   Бит 3 - D: флаг десятичного режима. Когда установлен и инструкции сложения
   с переносом или вычитания с переносом выполняются, исходные значения
   трактуются как действительные BCD (Binary Coded Decimal, 0x00-0x99 = 0-99)
   числа.

   Бит 4 - B: устанавливается, когда выполняется программное прерывание
   операция BRK).

   Бит 5: не используется. Предполагается все время быть логической единицей.

   Бит 6 - V - Флаг переполнения: когда арифметическая операция возвращает
   результат, слишком большой чтобы уместиться в 1 байте, устанавливается
   флаг V.

   Бит 7 - S - флаг знака: устанавливается, если результат операции
   отрицательный, очищен, если положительный.

   Наиболее часто используемые флаги - C, Z, V, S.

  

  ПРОГРАММНЫЙ СЧЕТЧИК

    Содержит адрес текущей выполняющейся инструкции машинного языка. С тех
  пор как операционная система стала постоянно выполняться на Commodore
  VIC-20 (либо, в другом случае, на любом компьютере), программный счетчик
  постоянно меняется. Он может быть остановлен только прерыванием
  микропроцессора каким-либо путем.


  УКАЗАТЕЛЬ СТЕКА

    Этот регистр содержит первую свободную ячейку в стеке. Стек используется
  для временного хранилища программами на машинного языке и компьютером.




  РЕЖИМЫ АДРЕСАЦИИ

    Инструкциям для работы нужны операнды. Есть множество способов указания,
  где процессор должен брать эти операнды. Различные методы, использующиеся
  для этого, называются режимами адресации. Процессор 6502 предлагает 11
  режимов, как описано ниже.

  1) IMM - Непосредственная адресация
  В этом режиме значение операнда дается внутри самой инструкции. На языке
  ассемблера оно указывается значком "#" перед операндом.
  Например, LDA #$0A - означает "загрузить в аккумулятор шестнадцатиричное
  значение 0A".
  В машинном коде различные режимы указываются различными кодами. Таким
  образом команда LDA может быть переведена в различные коды, в зависимости
  от режима адресации. В этом режиме код будет таким: $A9 $0A

  2 и 3) ABS & ZP - Прямая адресация и прямая адресация нулевой страницы
  В этих режимах выдается адрес операндов.
  Например, LDA $31F6 - (ассемблер)
            $AD $31F6 - (машинный код)
  Если адрес находится на нулевой странице, т.е. любой адрес, где старший
  байт - нулевой, только один байт нужен для адресации. Процессор
  автоматически обнуляет старший байт.
  Например, LDA $F4
            $A5 $F4
  Заметьте, что для различных режимов адресации используются различные режимы
  адресации.
  Заметьте также, что для двубайтных адресов младший байт располагается
  первым, например команда LDA $31F6 хранится в памяти как три байта:
  $AD $F6 $31.
  Прямая адресация нулевой страницы обычно называется просто адресацией
  нулевой страницы.

  4) IMP - Неявная адресация
  Для этого режимя не требуется никаких адресов для операндов. Они
  подразумеваются самой инструкцией.
  Например, TAX - (передать содержимое аккумулятора в регистр X)
            $AA

  5) ACC - Аккумуляторная адресация
  В этом режиме оперирует с данными в аккумуляторе, поэтому операнды не
  нужны.
  Например, LSR A - (логический сдвиг вправо на 1 бит)
            $4A

  6 и 7) ABS, R & ZP, R - Индексированная адресация и индексированная
  адресация нулевой страницы
  В этих режимах данный адрес складывается со значением индексного регистра
  либо X, либо Y для получения реального адреса операнда.
  Например, LDA $31F6, Y
            $D9 $31F6
            LDA $31F6, X
            $DD $31F6
  Заметьте, что различные коды операций определяют используемый индексный
  регистр.
  В режиме адресации нулевой страницы вы должны уяснить, что регистры X и Y
  не являются взаимозаменяемыми. Большинство инструкций, которые могут
  использоваться с индексацией нулевой страницы, выполняются только с
  регистром X.
  Например, LDA $20, X
            $B5 $20
  
  8) IND - Косвенная адресация
  Этот режим применяется только к инструкции JMP. Указывается круглыми
  скобками вокруг операнда. Операндом является адрес, содержащий новое
  значение для программного счетчика.
  Например, JMP ($215F)
  Предположим следующее -       байт   значение
                                $215F  $76
                                $2160  $30
  Эта инструкция берет значения байтов по адресу $215F и $2160 и использует
  их как адрес для перехода, т.е. $3076 (помните, что адреса хранятся в
  памяти, начиная с младшего байта)

  9) IND, X - Индексно-косвенная адресация
  В этом режиме адрес на нулевой странице добавляется к содержимому регистра
  X, чтобы получить адрес, содержащий адрес операнда. Косвенная адресация
  указывается круглыми скобками на языке ассемблера.
  Например, LDA ($3E, X)
            $A1 $3E
  Предположим следующее -       байт   значение
                                X-рег.    $05
                                $0043     $15
                                $0044     $24
                                $2415     $6E

  Тогда инструкция выполнится так:
  (1) сложение $3E и $05 = $0043
  (2) получение адреса, содержащегося в байтах $0043, $0044 = $2415
  (3) загрузка содержимого по адресу $2415 - т.е. $6E - в аккумулятор.
  Примечание а) При сложении однобайтного адреса и регистра X используется
                младший байт суммы - т.е. результат сложения всегда будет
                адресом на нулевой странице.
                Например, FF + 2 = 0001 (не 0101, как вы могли ожидать).
                НЕ ЗАБЫВАЙТЕ ПРИ ЭМУЛЯЦИИ ДАННОГО РЕЖИМА.
             б) В этом режиме используется только регистр X.

  10) IND, Y - Косвенно-индексная адресация
  В этом режиме содержимое адреса на нулевой странице (и следующий байт)
  возвращает косвенный адрес, который суммируется с содержимым регистра Y для
  получения реального адреса операнда. Снова на машинном языке инструкция
  указывается круглыми скобками.
  Например LDA ($4C), Y
  Заметьте, что в скобки заключен только второй байт инструкции, поскольку
  только эта часть является косвенной.
  Предположим следующее -       байт   значение
                                $004C      $00
                                $004D      $21
                                Y-рег.     $05
                                $2105      $6D
  Тогда иструкция выше выполнится так:
  (1) получение адреса, содержащегося в байтах $004C, $004D = $2100
  (2) сложение с содержимым регистра Y = $2105
  (3) загрузка содержимого по адресу $2105, т.е. $6D в аккумулятор.
  Примечание: В этом режиме используется только регистр Y.

  11) REL - Относительная адресация
  Этот режим используется с командами перехода по условию. Вероятно вы будете
  использовать его очень часто. Однобайтное значение добавляется к
  программному счетчику, и программа продолжает выполнение с этого адреса.
  Однобайтное число интерпретируется как число со знаком - т.е. если 7-й бит
  равен 1, то биты 0-6 данного байта отрицательны; если 7-й бит равен 0, то
  число положительно. Это дает возможность использовать смещение для перехода
  до 127 байт в любом направлении.
  Например, № бита    7 6 5 4 3 2 1 0    число со знаком    число без знака
            значение  1 0 1 0 0 1 1 1    -39                $A7
            значение  0 0 1 0 0 1 1 1    +39                $27
  Пример инструкции:
    BEQ $A7
    $F0 $A7
  Эта инструкция проверяет состояние флага Z. Если он установлен, десятичное
  число 39 будет вычтено из программного счетчика, и выполнение продолжится с
  полученного адреса. Если Флаг Z не установлен, выполнение продолжится со
  следующей команды.
  Примечания: а) Перед тем, как смещение для перехода будет добавлено,
                 программный счетчик указывает на начало инструкции,
                 находящейся после инструкции перехода. Примите это во
                 внимание при расчете смещений.
              б) Инструкции перехода по условию работают, проверяя
                 соответствующие биты в флаговом регистре. Убедитесь, что они
                 установлены или сброшены так как вам нужно. Это часто
                 делается, используя инструкцию CMP.
              в) Если вы обнаружили, что вам нужен переход больше, чем на
                 127 байт, используйте противоположное условие перехода и
                 JMP.


  +------------------------------------------------------------------------
  |
  |     НАБОР ИНСТРУКЦИЙ МИКРОПРОЦЕССОРА MCS6502 - В АЛФАВИТНОМ ПОРЯДКЕ
  |
  +------------------------------------------------------------------------
  |
  |     ADC   Add Memory to Accumulator with Carry
  |     AND   "AND" Memory with Accumulator
  |     ASL   Shift Left One Bit (Memory or Accumulator)
  |
  |     BCC   Branch on Carry Clear
  |     BCS   Branch on Carry Set
  |     BEQ   Branch on Result Zero
  |     BIT   Test Bits in Memory with Accumulator
  |     BMI   Branch on Result Minus
  |     BNE   Branch on Result not Zero
  |     BPL   Branch on Result Plus
  |     BRK   Force Break
  |     BVC   Branch on Overflow Clear
  |     BVS   Branch on Overflow Set
  |
  |     CLC   Clear Carry Flag
  |     CLD   Clear Decimal Mode
  |     CLI   Clear interrupt Disable Bit
  |     CLV   Clear Overflow Flag
  |     CMP   Compare Memory and Accumulator
  |     CPX   Compare Memory and Index X
  |     CPY   Compare Memory and Index Y
  |
  |     DEC   Decrement Memory by One
  |     DEX   Decrement Index X by One
  |     DEY   Decrement Index Y by One
  |
  |     EOR   "Exclusive-Or" Memory with Accumulator
  |
  |     INC   Increment Memory by One
  |     INX   Increment Index X by One
  |     INY   Increment Index Y by One
  |
  |     JMP   Jump to New Location
  |
  +------------------------------------------------------------------------


  ------------------------------------------------------------------------+
                                                                          |
        НАБОР ИНСТРУКЦИЙ МИКРОПРОЦЕССОРА MCS6502 - В АЛФАВИТНОМ ПОРЯДКЕ   |
                                                                          |
  ------------------------------------------------------------------------+
                                                                          |
        JSR   Jump to New Location Saving Return Address                  |
                                                                          |
        LDA   Load Accumulator with Memory                                |
        LDX   Load Index X with Memory                                    |
        LDY   Load Index Y with Memory                                    |
        LSR   Shift Right One Bit (Memory or Accumulator)                 |
                                                                          |
        NOP   No Operation                                                |
                                                                          |
        ORA   "OR" Memory with Accumulator                                |
                                                                          |
        PHA   Push Accumulator on Stack                                   |
        PHP   Push Processor Status on Stack                              |
        PLA   Pull Accumulator from Stack                                 |
        PLP   Pull Processor Status from Stack                            |
                                                                          |
        ROL   Rotate One Bit Left (Memory or Accumulator)                 |
        ROR   Rotate One Bit Right (Memory or Accumulator)                |
        RTI   Return from Interrupt                                       |
        RTS   Return from Subroutine                                      |
                                                                          |
        SBC   Subtract Memory from Accumulator with Borrow                |
        SEC   Set Carry Flag                                              |
        SED   Set Decimal Mode                                            |
        SEI   Set Interrupt Disable Status                                |
        STA   Store Accumulator in Memory                                 |
        STX   Store Index X in Memory                                     |
        STY   Store Index Y in Memory                                     |
                                                                          |
        TAX   Transfer Accumulator to Index X                             |
        TAY   Transfer Accumulator to Index Y                             |
        TSX   Transfer Stack Pointer to Index X                           |
        TXA   Transfer Index X to Accumulator                             |
        TXS   Transfer Index X to Stack Pointer                           |
        TYA   Transfer Index Y to Accumulator                             |
  ------------------------------------------------------------------------+


                Принята следующая система обозначений:


     A       Аккумулятор                  EOR     Логическое исключающее ИЛИ

     X, Y    Индексный регистр            fromS   Передача из стека

     M       Память                       toS     Передача в стек

     P       Регистр состояния процессора ->      Передача в

     S       Указатель стека              <-      Передача из

     /       Меняется                     V       Логическое или

     _       Не меняется                  PC      Программный счетчик

     +       Сложение                     PCH     Старший байт PC

     /\      логическое И                 PCL     Младший байт PC

     -       Вычитание                    OPER    Операнд

                                          #       Непосредственный режим
                                                  адресации



  Примечание: Вверху каждой таблицы в скобках расположена ссылка с номером
              (Ref: XX), которая указывает на тот Раздел Руководства
              Программиста Семейства Микрокомпьютеров MCS6500, где инструкция
              определена.




  ADC               Add memory to accumulator with carry                ADC

  Операция:   A + M + C -> A, C                         N Z C I D V
                                                        / / / _ _ /
                                (Ref: 2.2.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   ADC #Oper           |    69   |    2    |    2     |
  |  ZP            |   ADC Oper            |    65   |    2    |    3     |
  |  ZP, X         |   ADC Oper,X          |    75   |    2    |    4     |
  |  ABS           |   ADC Oper            |    6D   |    3    |    4     |
  |  ABS, X        |   ADC Oper,X          |    7D   |    3    |    4*    |
  |  ABS, Y        |   ADC Oper,Y          |    79   |    3    |    4*    |
  |  IND, X        |   ADC (Oper,X)        |    61   |    2    |    6     |
  |  IND, Y        |   ADC (Oper),Y        |    71   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 если пересекается страничная граница

  AND                  "AND" memory with accumulator                    AND

  Операция:   A /\ M -> A                               N Z C I D V
                                                        / / _ _ _ _
                               (Ref: 2.2.3.0)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   AND #Oper           |    29   |    2    |    2     |
  |  ZP            |   AND Oper            |    25   |    2    |    3     |
  |  ZP, X         |   AND Oper,X          |    35   |    2    |    4     |
  |  ABS           |   AND Oper            |    2D   |    3    |    4     |
  |  ABS, X        |   AND Oper,X          |    3D   |    3    |    4*    |
  |  ABS, Y        |   AND Oper,Y          |    39   |    3    |    4*    |
  |  IND, X        |   AND (Oper,X)        |    21   |    2    |    6     |
  |  IND, Y        |   AND (Oper),Y        |    31   |    2    |    5     |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 если пересекается страничная граница


  ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL
                   +-+-+-+-+-+-+-+-+
  Операция:   C <- |7|6|5|4|3|2|1|0| <- 0
                   +-+-+-+-+-+-+-+-+                    N Z C I D V
                                                        / / / _ _ _
                                 (Ref: 10.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ACC           |   ASL A               |    0A   |    1    |    2     |
  |  ZP            |   ASL Oper            |    06   |    2    |    5     |
  |  ZP, X         |   ASL Oper,X          |    16   |    2    |    6     |
  |  ABS           |   ASL Oper            |    0E   |    3    |    6     |
  |  ABS, X        |   ASL Oper,X          |    1E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+


  BCC                     BCC Branch on Carry Clear                     BCC
                                                        N Z C I D V
  Операция:   Branch on C = 0                           _ _ _ _ _ _
                               (Ref: 4.1.1.3)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BCC Oper            |    90   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BCS                      BCS Branch on carry set                      BCS

  Операция:   Branch on C = 1                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.4)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BCS Oper            |    B0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BEQ                    BEQ Branch on result zero                      BEQ
                                                        N Z C I D V
  Операция:   Branch on Z = 1                           _ _ _ _ _ _
                               (Ref: 4.1.1.5)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BEQ Oper            |    F0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BIT             BIT Test bits in memory with accumulator              BIT

  Операция:   A /\ M, M7 -> N, M6 -> V

  6 и 7 биты копируются в регистр состояния. Если       N Z C I D V
  результат A /\ M будет нулевым, тогда Z = 1, иначе    M7/ _ _ _ M6
  Z = 0
                               (Ref: 4.2.1.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   BIT Oper            |    24   |    2    |    3     |
  |  ABS           |   BIT Oper            |    2C   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  BMI                    BMI Branch on result minus                     BMI

  Операция:   Branch on N = 1                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BMI Oper            |    30   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BNE                   BNE Branch on result not zero                   BNE

  Операция:   Branch on Z = 0                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.6)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BMI Oper            |    D0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BPL                     BPL Branch on result plus                     BPL

  Операция:   Branch on N = 0                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BPL Oper            |    10   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BRK                          BRK Force Break                          BRK

  Операция:   Forced Interrupt PC + 2 toS P toS         N Z C I D V
                                                        _ _ _ 1 _ _
                                 (Ref: 9.11)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   BRK                 |    00   |    1    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  1. Команда BRK не может быть заменена установкой флага I.


  BVC                   BVC Branch on overflow clear                    BVC

  Операция:   Branch on V = 0                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.8)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BVC Oper            |    50   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  BVS                    BVS Branch on overflow set                     BVS

  Операция:   Branch on V = 1                           N Z C I D V
                                                        _ _ _ _ _ _
                               (Ref: 4.1.1.7)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  REL           |   BVS Oper            |    70   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 при переходе на ту же страницу
  * увеличивается на 2 при переходе на другую страницу


  CLC                       CLC Clear carry flag                        CLC

  Операция:   0 -> C                                    N Z C I D V
                                                        _ _ 0 _ _ _
                                (Ref: 3.0.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   CLC                 |    18   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLD                      CLD Clear decimal mode                       CLD

  Операция:   0 -> D                                    N A C I D V
                                                        _ _ _ _ 0 _
                                (Ref: 3.3.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   CLD                 |    D8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLI                  CLI Clear interrupt disable bit                  CLI

  Операция:   0 -> I                                     N Z C I D V
                                                        _ _ _ 0 _ _
                                (Ref: 3.2.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   CLI                 |    58   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLV                      CLV Clear overflow flag                      CLV

  Операция:   0 -> V                                     N Z C I D V
                                                        _ _ _ _ _ 0
                                (Ref: 3.6.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   CLV                 |    B8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CMP                CMP Compare memory and accumulator                 CMP

  Операция:   A - M                                     N Z C I D V
                                                        / / / _ _ _
                                (Ref: 4.2.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   CMP #Oper           |    C9   |    2    |    2     |
  |  ZP            |   CMP Oper            |    C5   |    2    |    3     |
  |  ZP, X         |   CMP Oper,X          |    D5   |    2    |    4     |
  |  ABS           |   CMP Oper            |    CD   |    3    |    4     |
  |  ABS, X        |   CMP Oper,X          |    DD   |    3    |    4*    |
  |  ABS, Y        |   CMP Oper,Y          |    D9   |    3    |    4*    |
  |  IND, X        |   CMP (Oper,X)        |    C1   |    2    |    6     |
  |  IND, Y        |   CMP (Oper),Y        |    D1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 если пересекается страничная граница

  CPX                  CPX Compare Memory and Index X                   CPX
                                                        N Z C I D V
  Операция:   X - M                                     / / / _ _ _
                                 (Ref: 7.8)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   CPX *Oper           |    E0   |    2    |    2     |
  |  ZP            |   CPX Oper            |    E4   |    2    |    3     |
  |  ABS           |   CPX Oper            |    EC   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+

  CPY                  CPY Compare memory and index Y                   CPY
                                                        N Z C I D V
  Операция:   Y - M                                     / / / _ _ _
                                 (Ref: 7.9)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   CPY *Oper           |    C0   |    2    |    2     |
  |  ZP            |   CPY Oper            |    C4   |    2    |    3     |
  |  ABS           |   CPY Oper            |    CC   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  DEC                   DEC Decrement memory by one                     DEC

  Операция:   M - 1 -> M                                N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 10.7)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   DEC Oper            |    C6   |    2    |    5     |
  |  ZP, X         |   DEC Oper,X          |    D6   |    2    |    6     |
  |  ABS           |   DEC Oper            |    CE   |    3    |    6     |
  |  ABS, X        |   DEC Oper,X          |    DE   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+


  DEX                   DEX Decrement index X by one                    DEX

  Операция:   X - 1 -> X                                N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.6)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   DEX                 |    CA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  DEY                   DEY Decrement index Y by one                    DEY

  Операция:   X - 1 -> Y                                N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.7)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   DEY                 |    88   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  EOR            EOR "Exclusive-Or" memory with accumulator             EOR

  Операция:   A EOR M -> A                              N Z C I D V
                                                        / / _ _ _ _
                               (Ref: 2.2.3.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   EOR #Oper           |    49   |    2    |    2     |
  |  ZP            |   EOR Oper            |    45   |    2    |    3     |
  |  ZP, X         |   EOR Oper,X          |    55   |    2    |    4     |
  |  ABS           |   EOR Oper            |    4D   |    3    |    4     |
  |  ABS, X        |   EOR Oper,X          |    5D   |    3    |    4*    |
  |  ABS, Y        |   EOR Oper,Y          |    59   |    3    |    4*    |
  |  IND, X        |   EOR (Oper,X)        |    41   |    2    |    6     |
  |  IND, Y        |   EOR (Oper),Y        |    51   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 если пересекается страничная граница

  INC                    INC Increment memory by one                    INC
                                                        N Z C I D V
  Операция:   M + 1 -> M                                / / _ _ _ _
                                 (Ref: 10.6)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   INC Oper            |    E6   |    2    |    5     |
  |  ZP, X         |   INC Oper,X          |    F6   |    2    |    6     |
  |  ABS           |   INC Oper            |    EE   |    3    |    6     |
  |  ABS, X        |   INC Oper,X          |    FE   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+

  INX                    INX Increment Index X by one                   INX
                                                        N Z C I D V
  Операция:   X + 1 -> X                                / / _ _ _ _
                                 (Ref: 7.4)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   INX                 |    E8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  INY                    INY Increment Index Y by one                   INY

  Операция:   X + 1 -> X                                N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.5)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   INY                 |    C8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  JMP                     JMP Jump to new location                      JMP

  Операция:   (PC + 1) -> PCL                           N Z C I D V
              (PC + 2) -> PCH   (Ref: 4.0.2)            _ _ _ _ _ _
                                (Ref: 9.8.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ABS           |   JMP Oper            |    4C   |    3    |    3     |
  |  IND           |   JMP (Oper)          |    6C   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+


  JSR          JSR Jump to new location saving return address           JSR

  Операция:   PC + 2 toS, (PC + 1) -> PCL               N Z C I D V
                          (PC + 2) -> PCH               _ _ _ _ _ _
                                 (Ref: 8.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ABS           |   JSR Oper            |    20   |    3    |    6     |
  +----------------+-----------------------+---------+---------+----------+


  LDA                  LDA Load accumulator with memory                 LDA

  Операция:   M -> A                                    N Z C I D V
                                                        / / _ _ _ _
                                (Ref: 2.1.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   LDA #Oper           |    A9   |    2    |    2     |
  |  ZP            |   LDA Oper            |    A5   |    2    |    3     |
  |  ZP, X         |   LDA Oper,X          |    B5   |    2    |    4     |
  |  ABS           |   LDA Oper            |    AD   |    3    |    4     |
  |  ABS, X        |   LDA Oper,X          |    BD   |    3    |    4*    |
  |  ABS, Y        |   LDA Oper,Y          |    B9   |    3    |    4*    |
  |  IND, X        |   LDA (Oper,X)        |    A1   |    2    |    6     |
  |  IND, Y        |   LDA (Oper),Y        |    B1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 если пересекается страничная граница


  LDX                   LDX Load index X with memory                    LDX

  Операция:   M -> X                                    N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.0)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   LDX #Oper           |    A2   |    2    |    2     |
  |  ZP            |   LDX Oper            |    A6   |    2    |    3     |
  |  ZP, Y         |   LDX Oper,Y          |    B6   |    2    |    4     |
  |  ABS           |   LDX Oper            |    AE   |    3    |    4     |
  |  ABS, Y        |   LDX Oper,Y          |    BE   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 когда пересекается страничная граница


  LDY                   LDY Load index Y with memory                    LDY
                                                        N Z C I D V
  Операция:   M -> Y                                    / / _ _ _ _
                                 (Ref: 7.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   LDY #Oper           |    A0   |    2    |    2     |
  |  ZP            |   LDY Oper            |    A4   |    2    |    3     |
  |  ZP, X         |   LDY Oper,X          |    B4   |    2    |    4     |
  |  ABS           |   LDY Oper            |    AC   |    3    |    4     |
  |  ABS, X        |   LDY Oper,X          |    BC   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 когда пересекается страничная граница


  LSR          LSR Shift right one bit (memory or accumulator)          LSR

                   +-+-+-+-+-+-+-+-+
  Операция:   0 -> |7|6|5|4|3|2|1|0| -> C               N Z C I D V
                   +-+-+-+-+-+-+-+-+                    0 / / _ _ _
                                 (Ref: 10.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ACC           |   LSR A               |    4A   |    1    |    2     |
  |  ZP            |   LSR Oper            |    46   |    2    |    5     |
  |  ZP, X         |   LSR Oper,X          |    56   |    2    |    6     |
  |  ABS           |   LSR Oper            |    4E   |    3    |    6     |
  |  ABS, X        |   LSR Oper,X          |    5E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+


  NOP                         NOP No operation                          NOP
                                                        N Z C I D V
  Операция:   No Operation (2 cycles)                   _ _ _ _ _ _

  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   NOP                 |    EA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  ORA                 ORA "OR" memory with accumulator                  ORA

  Операция:   A V M -> A                                 N Z C I D V
                                                        / / _ _ _ _
                               (Ref: 2.2.3.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   ORA #Oper           |    09   |    2    |    2     |
  |  ZP            |   ORA Oper            |    05   |    2    |    3     |
  |  ZP, X         |   ORA Oper,X          |    15   |    2    |    4     |
  |  ABS           |   ORA Oper            |    0D   |    3    |    4     |
  |  ABS, X        |   ORA Oper,X          |    1D   |    3    |    4*    |
  |  ABS, Y        |   ORA Oper,Y          |    19   |    3    |    4*    |
  |  IND, X        |   ORA (Oper,X)        |    01   |    2    |    6     |
  |  IND, Y        |   ORA (Oper),Y        |    11   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 на пересечени страниц


  PHA                   PHA Push accumulator on stack                   PHA

  Операция:   A toS                                     N Z C I D V
                                                        _ _ _ _ _ _
                                 (Ref: 8.5)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   PHA                 |    48   |    1    |    3     |
  +----------------+-----------------------+---------+---------+----------+


  PHP                 PHP Push processor status on stack                PHP

  Операция:   P toS                                     N Z C I D V
                                                        _ _ _ _ _ _
                                 (Ref: 8.11)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   PHP                 |    08   |    1    |    3     |
  +----------------+-----------------------+---------+---------+----------+


  PLA                 PLA Pull accumulator from stack                   PLA

  Операция:   A fromS                                   N Z C I D V
                                                        _ _ _ _ _ _
                                 (Ref: 8.6)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   PLA                 |    68   |    1    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  PLP               PLP Pull processor status from stack                PLA

  Операция:   P fromS                                   N Z C I D V
                                                         From Stack
                                 (Ref: 8.12)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   PLP                 |    28   |    1    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  ROL          ROL Rotate one bit left (memory or accumulator)          ROL

               +------------------------------+
               |         M or A               |
               |   +-+-+-+-+-+-+-+-+    +-+   |
  Операция:    +-< |7|6|5|4|3|2|1|0| <- |C| <-+         N Z C I D V
                   +-+-+-+-+-+-+-+-+    +-+             / / / _ _ _
                                 (Ref: 10.3)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ACC           |   ROL A               |    2A   |    1    |    2     |
  |  ZP            |   ROL Oper            |    26   |    2    |    5     |
  |  ZP, X         |   ROL Oper,X          |    36   |    2    |    6     |
  |  ABS           |   ROL Oper            |    2E   |    3    |    6     |
  |  ABS, X        |   ROL Oper,X          |    3E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+


  ROR          ROR Rotate one bit right (memory or accumulator)         ROR

               +------------------------------+
               |                              |
               |   +-+    +-+-+-+-+-+-+-+-+   |
  Операция:    +-> |C| -> |7|6|5|4|3|2|1|0| >-+         N Z C I D V
                   +-+    +-+-+-+-+-+-+-+-+             / / / _ _ _
                                 (Ref: 10.4)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ACC           |   ROR A               |    6A   |    1    |    2     |
  |  ZP            |   ROR Oper            |    66   |    2    |    5     |
  |  ZP, X         |   ROR Oper,X          |    76   |    2    |    6     |
  |  ABS           |   ROR Oper            |    6E   |    3    |    6     |
  |  ABS, X        |   ROR Oper,X          |    7E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+

    Примечание: инструкция ROR доступна в микропроцессорах MCS650X с 
                Июня 1976 г.


  RTI                    RTI Return from interrupt                      RTI
                                                        N Z C I D V
  Операция:   P fromS PC fromS                           From Stack
                                 (Ref: 9.6)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   RTI                 |    40   |    1    |    6     |
  +----------------+-----------------------+---------+---------+----------+


  RTS                    RTS Return from subroutine                     RTS
                                                        N Z C I D V
  Операция:   PC fromS, PC + 1 -> PC                    _ _ _ _ _ _
                                 (Ref: 8.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   RTS                 |    60   |    1    |    6     |
  +----------------+-----------------------+---------+---------+----------+


  SBC          SBC Subtract memory from accumulator with borrow         SBC
                      -
  Операция:   A - M - C -> A                            N Z C I D V
         -                                              / / / _ _ /
    Note:C = Borrow             (Ref: 2.2.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMM           |   SBC #Oper           |    E9   |    2    |    2     |
  |  ZP            |   SBC Oper            |    E5   |    2    |    3     |
  |  ZP, X         |   SBC Oper,X          |    F5   |    2    |    4     |
  |  ABS           |   SBC Oper            |    ED   |    3    |    4     |
  |  ABS, X        |   SBC Oper,X          |    FD   |    3    |    4*    |
  |  ABS, Y        |   SBC Oper,Y          |    F9   |    3    |    4*    |
  |  IND, X        |   SBC (Oper,X)        |    E1   |    2    |    6     |
  |  IND, Y        |   SBC (Oper),Y        |    F1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * увеличивается на 1 когда пересекается страничная граница


  SEC                        SEC Set carry flag                         SEC

  Операция:   1 -> C                                    N Z C I D V
                                                        _ _ 1 _ _ _
                                (Ref: 3.0.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   SEC                 |    38   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  SED                       SED Set decimal mode                        SED
                                                        N Z C I D V
  Операция:   1 -> D                                    _ _ _ _ 1 _
                                (Ref: 3.3.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   SED                 |    F8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  SEI                 SEI Set interrupt disable status                  SED
                                                        N Z C I D V
  Операция:   1 -> I                                    _ _ _ 1 _ _
                                (Ref: 3.2.1)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   SEI                 |    78   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  STA                  STA Store accumulator in memory                  STA

  Операция:   A -> M                                    N Z C I D V
                                                        _ _ _ _ _ _
                                (Ref: 2.1.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   STA Oper            |    85   |    2    |    3     |
  |  ZP, X         |   STA Oper,X          |    95   |    2    |    4     |
  |  ABS           |   STA Oper            |    8D   |    3    |    4     |
  |  ABS, X        |   STA Oper,X          |    9D   |    3    |    5     |
  |  ABS, Y        |   STA Oper, Y         |    99   |    3    |    5     |
  |  IND, X        |   STA (Oper,X)        |    81   |    2    |    6     |
  |  IND, Y        |   STA (Oper),Y        |    91   |    2    |    6     |
  +----------------+-----------------------+---------+---------+----------+


  STX                    STX Store index X in memory                    STX

  Операция:   X -> M                                    N Z C I D V
                                                        _ _ _ _ _ _
                                 (Ref: 7.2)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   STX Oper            |    86   |    2    |    3     |
  |  ZP, Y         |   STX Oper,Y          |    96   |    2    |    4     |
  |  ABS           |   STX Oper            |    8E   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  STY                    STY Store index Y in memory                    STY

  Операция:   Y -> M                                    N Z C I D V
                                                        _ _ _ _ _ _
                                 (Ref: 7.3)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  ZP            |   STY Oper            |    84   |    2    |    3     |
  |  ZP, X         |   STY Oper,X          |    94   |    2    |    4     |
  |  ABS           |   STY Oper            |    8C   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  TAX                TAX Transfer accumulator to index X                TAX

  Операция:   A -> X                                    N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.11)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TAX                 |    AA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TAY                TAY Transfer accumulator to index Y                TAY

  Операция:   A -> Y                                    N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.13)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TAY                 |    A8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TSX              TSX Transfer stack pointer to index X                TSX

  Операция:   S -> X                                    N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 8.9)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TSX                 |    BA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  TXA                TXA Transfer index X to accumulator                TXA
                                                        N Z C I D V
  Операция:   X -> A                                    / / _ _ _ _
                                 (Ref: 7.12)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TXA                 |    8A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  TXS              TXS Transfer index X to stack pointer                TXS
                                                        N Z C I D V
  Операция:   X -> S                                    _ _ _ _ _ _
                                 (Ref: 8.8)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TXS                 |    9A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  TYA                TYA Transfer index Y to accumulator                TYA

  Операция:   Y -> A                                    N Z C I D V
                                                        / / _ _ _ _
                                 (Ref: 7.14)
  +----------------+-----------------------+---------+---------+----------+
  | Режим адресации| Ассемблер, Мнемоника  |   КОД   |К-во байт|К-во цикл.|
  +----------------+-----------------------+---------+---------+----------+
  |  IMP           |   TYA                 |    98   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+



  +------------------------------------------------------------------------
  | РЕЖИМЫ АДРЕСАЦИИ ИНСТРУКЦИЙ И ОТНОСИТЕЛЬНОЕ ВРЕМЯ ВЫПОЛНЕНИЯ
  | (в тактах микропроцессора)
  +------------------------------------------------------------------------

                  A   A   A   B   B   B   B   B   B   B   B   B   B   C
                  D   N   S   C   C   E   I   M   N   P   R   V   V   L
                  C   D   L   C   S   Q   T   I   E   L   K   C   S   C
  ACC          |  .   .   2   .   .   .   .   .   .   .   .   .   .   .
  IMM          |  2   2       .   .   .   .   .   .   .   .   .   .   .
  ZP           |  3   3   5   .   .   .   3   .   .   .   .   .   .   .
  ZP, X        |  4   4   6   .   .   .   .   .   .   .   .   .   .   .
  ZP, Y        |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  ABS          |  4   4   6   .   .   .   4   .   .   .   .   .   .   .
  ABS, X       |  4*  4*  7   .   .   .   .   .   .   .   .   .   .   .
  ABS, Y       |  4*  4*  .   .   .   .   .   .   .   .   .   .   .   .
  IMP          |  .   .   .   .   .   .   .   .   .   .   .   .   .   2
  REL          |  .   .   .   2** 2** 2** .   2** 2** 2** 7   2** 2** .
  IND, X       |  6   6   .   .   .   .   .   .   .   .   .   .   .   .
  IND, Y       |  5*  5*  .   .   .   .   .   .   .   .   .   .   .   .
  IND          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
               +-----------------------------------------------------------
                  C   C   C   C   C   C   D   D   D   E   I   I   I   J
                  L   L   L   M   P   P   E   E   E   O   N   N   N   M
                  D   I   V   P   X   Y   C   X   Y   R   C   X   Y   P
  ACC          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  IMM          |  .   .   .   2   2   2   .   .   .   2   .   .   .   .
  ZP           |  .   .   .   3   3   3   5   .   .   3   5   .   .   .
  ZP, X        |  .   .   .   4   .   .   6   .   .   4   6   .   .   .
  ZP, Y        |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  ABS          |  .   .   .   4   4   4   6   .   .   4   6   .   .   3
  ABS, X       |  .   .   .   4*  .   .   7   .   .   4*  7   .   .   .
  ABS, Y       |  .   .   .   4*  .   .   .   .   .   4*  .   .   .   .
  IMP          |  2   2   2   .   .   .   .   2   2   .   .   2   2   .
  REL          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  IND, X       |  .   .   .   6   .   .   .   .   .   6   .   .   .   .
  IND, Y       |  .   .   .   5*  .   .   .   .   .   5*  .   .   .   .
  IND          |  .   .   .   .   .   .   .   .   .   .   .   .   .   5
               +-----------------------------------------------------------
     *  Увеличивается на 1 если индексная адресация пересекает страничную
        границу
     ** Увеличивается на 1 если переход осуществлен и еще на 1 если операция
        перехода пересекает страничную границу


  ------------------------------------------------------------------------+
    РЕЖИМЫ АДРЕСАЦИИ ИНСТРУКЦИЙ И ОТНОСИТЕЛЬНОЕ ВРЕМЯ ВЫПОЛНЕНИЯ          |
    (в тактах микропроцессора)                                            |
  ------------------------------------------------------------------------+

                  J   L   L   L   L   N   O   P   P   P   P   R   R   R
                  S   D   D   D   S   O   R   H   H   L   L   O   O   T
                  R   A   X   Y   R   P   A   A   P   A   P   L   R   I
  ACC          |  .   .   .   .   2   .   .   .   .   .   .   2   2   .
  IMM          |  .   2   2   2   .   .   2   .   .   .   .   .   .   .
  ZP           |  .   3   3   3   5   .   3   .   .   .   .   5   5   .
  ZP, X        |  .   4   .   4   6   .   4   .   .   .   .   6   6   .
  ZP, Y        |  .   .   4   .   .   .   .   .   .   .   .   .   .   .
  ABS          |  6   4   4   4   6   .   4   .   .   .   .   6   6   .
  ABS, X       |  .   4*  .   4*  7   .   4*  .   .   .   .   7   7   .
  ABS, Y       |  .   4*  4*  .   .   .   4*  .   .   .   .   .   .   .
  IMP          |  .   .   .   .   .   2   .   3   3   4   4   .   .   6
  REL          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  IND, X       |  .   6   .   .   .   .   6   .   .   .   .   .   .   .
  IND, Y       |  .   5*  .   .   .   .   5*  .   .   .   .   .   .   .
  IND          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
               +-----------------------------------------------------------
                  R   S   S   S   S   S   S   S   T   T   T   T   T   T
                  T   B   E   E   E   T   T   T   A   A   S   X   X   Y
                  S   C   C   D   I   A   X   Y   X   Y   X   A   S   A
  ACC          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  IMM          |  .   2   .   .   .   .   .   .   .   .   .   .   .   .
  ZP           |  .   3   .   .   .   3   3   3   .   .   .   .   .   .
  ZP, X        |  .   4   .   .   .   4   .   4   .   .   .   .   .   .
  ZP, Y        |  .   .   .   .   .   .   4   .   .   .   .   .   .   .
  ABS          |  .   4   .   .   .   4   4   4   .   .   .   .   .   .
  ABS, X       |  .   4*  .   .   .   5   .   .   .   .   .   .   .   .
  ABS, Y       |  .   4*  .   .   .   5   .   .   .   .   .   .   .   .
  IMP          |  6   .   2   2   2   .   .   .   2   2   2   2   2   2
  REL          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
  IND, X       |  .   6   .   .   .   6   .   .   .   .   .   .   .   .
  IND, Y       |  .   5*  .   .   .   6   .   .   .   .   .   .   .   .
  IND          |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
               +-----------------------------------------------------------
     *  Увеличивается на 1 если индексная адресация пересекает страничную
        границу
     ** Увеличивается на 1 если переход осуществлен и еще на 1 если операция
        перехода пересекает страничную границу



        00 - BRK                        20 - JSR
        01 - ORA - (Indirect,X)         21 - AND - (Indirect,X)
        02 - Future Expansion           22 - Future Expansion
        03 - Future Expansion           23 - Future Expansion
        04 - Future Expansion           24 - BIT - Zero Page
        05 - ORA - Zero Page            25 - AND - Zero Page
        06 - ASL - Zero Page            26 - ROL - Zero Page
        07 - Future Expansion           27 - Future Expansion
        08 - PHP                        28 - PLP
        09 - ORA - Immediate            29 - AND - Immediate
        0A - ASL - Accumulator          2A - ROL - Accumulator
        0B - Future Expansion           2B - Future Expansion
        0C - Future Expansion           2C - BIT - Absolute
        0D - ORA - Absolute             2D - AND - Absolute
        0E - ASL - Absolute             2E - ROL - Absolute
        0F - Future Expansion           2F - Future Expansion
        10 - BPL                        30 - BMI
        11 - ORA - (Indirect),Y         31 - AND - (Indirect),Y
        12 - Future Expansion           32 - Future Expansion
        13 - Future Expansion           33 - Future Expansion
        14 - Future Expansion           34 - Future Expansion
        15 - ORA - Zero Page,X          35 - AND - Zero Page,X
        16 - ASL - Zero Page,X          36 - ROL - Zero Page,X
        17 - Future Expansion           37 - Future Expansion
        18 - CLC                        38 - SEC
        19 - ORA - Absolute,Y           39 - AND - Absolute,Y
        1A - Future Expansion           3A - Future Expansion
        1B - Future Expansion           3B - Future Expansion
        1C - Future Expansion           3C - Future Expansion
        1D - ORA - Absolute,X           3D - AND - Absolute,X
        1E - ASL - Absolute,X           3E - ROL - Absolute,X
        1F - Future Expansion           3F - Future Expansion

        40 - RTI                        60 - RTS
        41 - EOR - (Indirect,X)         61 - ADC - (Indirect,X)
        42 - Future Expansion           62 - Future Expansion
        43 - Future Expansion           63 - Future Expansion
        44 - Future Expansion           64 - Future Expansion
        45 - EOR - Zero Page            65 - ADC - Zero Page
        46 - LSR - Zero Page            66 - ROR - Zero Page
        47 - Future Expansion           67 - Future Expansion
        48 - PHA                        68 - PLA
        49 - EOR - Immediate            69 - ADC - Immediate
        4A - LSR - Accumulator          6A - ROR - Accumulator
        4B - Future Expansion           6B - Future Expansion
        4C - JMP - Absolute             6C - JMP - Indirect
        4D - EOR - Absolute             6D - ADC - Absolute
        4E - LSR - Absolute             6E - ROR - Absolute
        4F - Future Expansion           6F - Future Expansion
        50 - BVC                        70 - BVS
        51 - EOR - (Indirect),Y         71 - ADC - (Indirect),Y
        52 - Future Expansion           72 - Future Expansion
        53 - Future Expansion           73 - Future Expansion
        54 - Future Expansion           74 - Future Expansion
        55 - EOR - Zero Page,X          75 - ADC - Zero Page,X
        56 - LSR - Zero Page,X          76 - ROR - Zero Page,X
        57 - Future Expansion           77 - Future Expansion
        58 - CLI                        78 - SEI
        59 - EOR - Absolute,Y           79 - ADC - Absolute,Y
        5A - Future Expansion           7A - Future Expansion
        5B - Future Expansion           7B - Future Expansion
        5C - Future Expansion           7C - Future Expansion
        5D - EOR - Absolute,X           7D - ADC - Absolute,X
        5E - LSR - Absolute,X           7E - ROR - Absolute,X
        5F - Future Expansion           7F - Future Expansion

        80 - Future Expansion           A0 - LDY - Immediate
        81 - STA - (Indirect,X)         A1 - LDA - (Indirect,X)
        82 - Future Expansion           A2 - LDX - Immediate
        83 - Future Expansion           A3 - Future Expansion
        84 - STY - Zero Page            A4 - LDY - Zero Page
        85 - STA - Zero Page            A5 - LDA - Zero Page
        86 - STX - Zero Page            A6 - LDX - Zero Page
        87 - Future Expansion           A7 - Future Expansion
        88 - DEY                        A8 - TAY
        89 - Future Expansion           A9 - LDA - Immediate
        8A - TXA                        AA - TAX
        8B - Future Expansion           AB - Future Expansion
        8C - STY - Absolute             AC - LDY - Absolute
        8D - STA - Absolute             AD - LDA - Absolute
        8E - STX - Absolute             AE - LDX - Absolute
        8F - Future Expansion           AF - Future Expansion
        90 - BCC                        B0 - BCS
        91 - STA - (Indirect),Y         B1 - LDA - (Indirect),Y
        92 - Future Expansion           B2 - Future Expansion
        93 - Future Expansion           B3 - Future Expansion
        94 - STY - Zero Page,X          B4 - LDY - Zero Page,X
        95 - STA - Zero Page,X          B5 - LDA - Zero Page,X
        96 - STX - Zero Page,Y          B6 - LDX - Zero Page,Y
        97 - Future Expansion           B7 - Future Expansion
        98 - TYA                        B8 - CLV
        99 - STA - Absolute,Y           B9 - LDA - Absolute,Y
        9A - TXS                        BA - TSX
        9B - Future Expansion           BB - Future Expansion
        9C - Future Expansion           BC - LDY - Absolute,X
        9D - STA - Absolute,X           BD - LDA - Absolute,X
        9E - Future Expansion           BE - LDX - Absolute,Y
        9F - Future Expansion           BF - Future Expansion

        C0 - Cpy - Immediate            E0 - CPX - Immediate
        C1 - CMP - (Indirect,X)         E1 - SBC - (Indirect,X)
        C2 - Future Expansion           E2 - Future Expansion
        C3 - Future Expansion           E3 - Future Expansion
        C4 - CPY - Zero Page            E4 - CPX - Zero Page
        C5 - CMP - Zero Page            E5 - SBC - Zero Page
        C6 - DEC - Zero Page            E6 - INC - Zero Page
        C7 - Future Expansion           E7 - Future Expansion
        C8 - INY                        E8 - INX
        C9 - CMP - Immediate            E9 - SBC - Immediate
        CA - DEX                        EA - NOP
        CB - Future Expansion           EB - Future Expansion
        CC - CPY - Absolute             EC - CPX - Absolute
        CD - CMP - Absolute             ED - SBC - Absolute
        CE - DEC - Absolute             EE - INC - Absolute
        CF - Future Expansion           EF - Future Expansion
        D0 - BNE                        F0 - BEQ
        D1 - CMP   (Indirect@,Y         F1 - SBC - (Indirect),Y
        D2 - Future Expansion           F2 - Future Expansion
        D3 - Future Expansion           F3 - Future Expansion
        D4 - Future Expansion           F4 - Future Expansion
        D5 - CMP - Zero Page,X          F5 - SBC - Zero Page,X
        D6 - DEC - Zero Page,X          F6 - INC - Zero Page,X
        D7 - Future Expansion           F7 - Future Expansion
        D8 - CLD                        F8 - SED
        D9 - CMP - Absolute,Y           F9 - SBC - Absolute,Y
        DA - Future Expansion           FA - Future Expansion
        DB - Future Expansion           FB - Future Expansion
        DC - Future Expansion           FC - Future Expansion
        DD - CMP - Absolute,X           FD - SBC - Absolute,X
        DE - DEC - Absolute,X           FE - INC - Absolute,X
        DF - Future Expansion           FF - Future Expansion


РАБОТА ИНСТРУКЦИЙ

 Следующий код взят из VICE с целью показать, как работает каждая инструкция.
Поскольку мы хотим лишь увидеть саму работу инструкций, никакие особые режимы
адресации здесь не используются.

     src : адресуемый байт или данные
     SET_SIGN : включает\выключает флаг S, зависящий от бита 7.
     SET_ZERO : включает\выключает флаг Z, зависящий от того, был ли результат
                нулевым.
     SET_CARRY(condition) : Если условие condition имеет ненулевое значение,
                то флаг C включается, иначе выключается.
     SET_OVERFLOW(condition) : Если условие condition истинно, то флаг V
                включается, иначе выключается.
     SET_INTERRUPT :  }
     SET_BREAK :      }  То же самое, что для SET_CARRY и SET_OVERFLOW.
     SET_DECIMAL :    }
     REL_ADDR(PC, src) : возвращает относительный адрес, полученный сложением
                смещения src и программного счетчика PC.
     SET_SR : Устанавливает регистр состояния в заданное значение.
     GET_SR : Получает значение регистра состояния
     PULL : Вынимает байт из стека.
     PUSH : Кладет байт в стек.
     LOAD : Получает байт из ячейки памяти по указанному адресу.
     STORE : Записывает байт в ячейку памяти по указанному адресу.
     IF_CARRY, IF_OVERFLOW, IF_SIGN, IF_ZERO etc : Возвращает истину, если
                нужный флаг установлен, иначе возвращает ложь.
     clk : количество тактов, которые забирает инструкция. Это показано ниже в
                случаях, где количество тактов меняется в зависимости от
                результата инструкции (например инструкции перехода).

     AC = Аккумулятор
     XR = Регистр X
     YR = Регистр Y
     PC = Прогаммный счетчик
     SP = Указатель стека


// ADC
  procedure ADC;
  var
    temp: Integer;
  begin
    temp := src + AC + IF_CARRY;
    SET_ZERO(temp and $FF);	{ This is not valid in decimal mode }
    if IF_DECIMAL = 1 then
    begin
      if (((AC and $0F) + (src and $0F) + IF_CARRY) > 9) then
        temp += 6;
      SET_SIGN(temp);
      SET_OVERFLOW(not ((AC xor src) and $80) and ((AC xor temp) and $80));
      if (temp > $99) then
        temp += 96;
      SET_CARRY(temp > $99);
    end else 
    begin
      SET_SIGN(temp);
      SET_OVERFLOW(not ((AC xor src) and $80) and ((AC xor temp) and $80));
      SET_CARRY(temp > $FF);
    end;
    AC = BYTE(temp);
  end;

// AND
  procedure AND;
  begin
    src := src and AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC := src;
  end;

// ASL
  procedure ASL;
  begin
    SET_CARRY(src and $80);
    src := src shl 1;
    src := src and $FF;
    SET_SIGN(src);
    SET_ZERO(src);
  end;
  { STORE src in memory or accumulator depending on addressing mode. }

// BCC
  procedure BCC;
  begin
    if IF_CARRY = 0 then
    begin
      Inc(clk);
      if (PC and $FF00) <> (REL_ADDR(PC, src) and $FF00) then
        Inc(clk);
      PC = REL_ADDR(PC, src);
    end;
  end;

// BCS
    if (IF_CARRY()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BEQ
    if (IF_ZERO()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BIT
    SET_SIGN(src);
    SET_OVERFLOW(0x40 & src);	/* Copy bit 6 to OVERFLOW flag. */
    SET_ZERO(src & AC);

// BMI
    if (IF_SIGN()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BNE
    if (!IF_ZERO()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BPL
    if (!IF_SIGN()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BRK
    PC++;
    PUSH((PC >> 8) & 0xff);	/* Push return address onto the stack. */
    PUSH(PC & 0xff);
    SET_BREAK((1));             /* Set BFlag before pushing */
    PUSH(SR);
    SET_INTERRUPT((1));
    PC = (LOAD(0xFFFE) | (LOAD(0xFFFF) << 8));

// BVC
    if (!IF_OVERFLOW()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// BVS
    if (IF_OVERFLOW()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

// CLC
    SET_CARRY(0);

// CLD
    SET_DECIMAL(0);

// CLI
    SET_INTERRUPT(0);

// CLV
    SET_OVERFLOW(0);

// CMP
    src = AC - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

// CPX
    src = XR - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

// CPY
    src = YR - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

// DEC
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE(address, (src));

// DEX
    unsigned src = XR;
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

// DEY
    unsigned src = YR;
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

// EOR
    src ^= AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = src;

// INC
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE(address, (src));

// INX
    unsigned src = XR;
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src); 
    XR = (src);

// INY
    unsigned src = YR;
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

// JMP
    PC = (src);

// JSR
    PC--;
    PUSH((PC >> 8) & 0xff);	/* Push return address onto the stack. */
    PUSH(PC & 0xff);
    PC = (src);

// LDA
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);

// LDX
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

// LDY
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

// LSR
    SET_CARRY(src & 0x01);
    src >>= 1;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

// NOP
    Nothing.

// ORA
    src |= AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = src;

// PHA
    src = AC;
    PUSH(src);

// PHP
    src = GET_SR;
    PUSH(src);

// PLA
    src = PULL();
    SET_SIGN(src);	/* Change sign and zero flag accordingly. */
    SET_ZERO(src);

// PLP
    src = PULL();
    SET_SR((src));

// ROL
    src <<= 1;
    if (IF_CARRY()) src |= 0x1;
    SET_CARRY(src > 0xff);
    src &= 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

// ROR
    if (IF_CARRY()) src |= 0x100;
    SET_CARRY(src & 0x01);
    src >>= 1;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

// RTI
    src = PULL();
    SET_SR(src);
    src = PULL();
    src |= (PULL() << 8);	/* Load return address from stack. */
    PC = (src);

// RTS
    src = PULL();
    src += ((PULL()) << 8) + 1;	/* Load return address from stack and add 1.     */
    PC = (src);

// SBC
    unsigned int temp = AC - src - (IF_CARRY() ? 0 : 1);
    SET_SIGN(temp);
    SET_ZERO(temp & 0xff);	/* Sign and Zero are invalid in decimal mode     */
    SET_OVERFLOW(((AC ^ temp) & 0x80) && ((AC ^ src) & 0x80));
    if (IF_DECIMAL()) {
	if ( ((AC & 0xf) - (IF_CARRY() ? 0 : 1)) < (src & 0xf)) /* EP */ temp -= 6;
	if (temp > 0x99) temp -= 0x60;
    }
    SET_CARRY(temp < 0x100);
    AC = (temp & 0xff);

// SEC
    SET_CARRY((1));

// SED
    SET_DECIMAL((1));

// SEI
    SET_INTERRUPT((1));

// STA
    STORE(address, (src));

// STX
    STORE(address, (src));

// STY
    STORE(address, (src));

// TAX
    unsigned src = AC;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

// TAY
    unsigned src = AC;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

// TSX
    unsigned src = SP;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

// TXA
    unsigned src = XR;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);

// TXS
    unsigned src = XR;
    SP = (src);

// TYA
    unsigned src = YR;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);

